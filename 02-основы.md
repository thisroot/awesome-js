## Сложность выполения алгоритмов
О(1) - константный доступ - доступ за обращение
O(n) — линейная сложность - перебор по циклу
O(log n) — логарифмическая сложность - бинарный поиск
O(n^2) — квадратичная сложность сложность - вложенные переборы по циклам

## Алгоритмы
- Бинарный поиск - вход: отсортированный массив; сложность: O(log(n))
- Линейный поиск - вход: Массив; сложность О(n)
- Быстрая сортировка - Массив - О(n log(n))
- Сортировка слиянием - Массив - O(n log(n))
Пузырьковая сортировка - Массив - О(n^2)

## Структуры данных
- Массив - (выделленый размер) - O(n)
- Динамический массив (сам меняет размер) - О(n)
- (одно/дву)-cвязный список (содержит ссылку на поеследующий элемент) - О(n)
- Список с пропусками - (вероятностное определение) - О(log(n))

## Основы ООП
- Инкапсуляция - скрытие деталей реализации объектов, с целью сохранения целостности данных
- Наследование - сокращение кода посредством наследования от объектов реализующих требования к текущему объекту
- Абстагирование - декомпозиция свойств обьекта до минимально удовлетворяющих требованиям применимости объекта
- Полиморфизм - определение баланса качеств обьекта позволяющих встать в весь ряд родственных форм объекта

## принципы SOLID
- Single responsibility (прин­цип един­ствен­ной ответ­ствен­но­сти) - каждый обьект должен иметь одну обязанность, и эта обязанность должна быть инкапсулирована в класс
- Open-closed (прин­цип откры­то­сти / закры­то­сти) - програмные сущьности должны быть открыты для расширения но закрыты для изменения
- Liskov substitution (прин­цип под­ста­новки Бар­бары Лис­ков) - Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов
- Interface segregation (прин­цип раз­де­ле­ния интер­фейса) - клиениты интерфейсов не должны иметь неиспользуемые ими члены интерфейса ( следует упрощать интерфейсы )
- Принцип инверсии зависимостей - модули верхних уровней не должны зависеть от модулей нижних уровней, оба типа модулей должны зависеть от абстракций, не должны зависеть от деталей. Детали должны зависеть от абстракций.

## Типы ООП членов
- Виртуальный метод / функция - определенный в родительском классе и реализованный в дочерних. Позволяет к методам из родительского класса
- Абстрактный класс - это класс, у которого не реализован один или более методов
- Интерфейс - абстрактный класс у которого не реализован ни один метод
- Статический метод - метод класса а не экземаляра

## Загрузка и инициализация кода
- Код js в HTML исполняется синхронно. Т.е по мере чтения документа, но можно указать способ инициализации скрипта
  - async - асинхронно подргужает скрипт, и при полной его загрузке начинает исполнение
  - defer - загружается так же асинхронно, но гарантирует порядок инициализации скриптов, так же сработает после полной загрузки HTML документа
  - эти методы работают только для данных источника src, и не будут работать для кода внутри тела скрипта
  - если загружать через js, то будует применяться async его можно отключить => `script.async = false`

## Порядок выполнения скрипта
  1. Инициализация - скрипт сканируется на наличие Function Declaration и переменных, и выполняет их поднятие.
      1. Функции уже объявлены
      2. var - будет обьявлено но не проинициализированно (undefined), let и const не поднимаются (Referene Error)

## GC
- отслеживает достижение ссылок для объектов

## Use strict
- запрещает использовать глобальные переменные / обьявлять переменные без ключевого слова
- изменение свойства защищенного от записи `Object.defineProperty(obj1, 'x', { value: 42, writable: false });`
- изменение свойства имеющего только getter `var obj2 = { get x() { return 17; } }`
- добавление свойства объекту, защищенному от расширения `var fixed = {}; Object.preventExtensions(fixed);`
- переопределять свойства значений `var o = { p: 1, p: 2 };`
- передавать аргументы имеющие одинаковую ссылку на данные `function sum(a, a, c)`
- при передаче значения this в функцию с помощью call, apply, bind - это значение не оборачивается в обьект
    ```js
        function test() { return this; }
        console.log(test() === undefined);  // false
        console.log(test.call(2) === 2);  // false
        console.log(test.apply(undefined) === undefined);  // false

        'use strict';
        function test() { return this; }
        console.log(test() === undefined);  // true
        console.log(test.call(2) === 2);  // true
        console.log(test.apply(undefined) === undefined);  // true
    ```
## let, const, var
- var - ограничивает видимость на уровне функций
- let - ограничивет видимость на уровне блоков
- const - неизменяемые переменные - но в константных обьектах можно изменять свойства если они относятся к тому же типу данных

## == и ===
- == проверяет равенство с приведением типов
- === проверяет равенство без приведения типов

## Function Declaration и Function Expression
- Function Declaration - поднимаются вверх
- Function Expression - опрделяюся на месте

## Приведение типов
- `[]` `{}` и обьекты cсозданные через конструкторы `Date()`, `Boolean()`, `Number()` = всегда будут true даже так `Boolean(false)`
- если в объекте есть метод `toString` - то при приведении выводится значение метода иначе `"[object Object]"`
- если есть объект valueOf то при численном приведении он перекрывает toString исключение Date

## Получение информации о типе объекта
- JS не предоставляет открытых способов
- Можно использовать уловку. Метод toString для обьекта.
- Применимо только для нативных обьектов
  - `var toString = {}.toString; var arr = [1, 2]; console.log( toString.call(arr) ); // [object Array]`
- Для собственных обектов можно узнать принадлежность к конструктору
  - `function User() {} var user = new User(); alert( user instanceof User ); // true`

  
## функция конструктор new
- если мы используем функцию конструктор ( т.е функции вызываемой через new) то она возвращает `this` если нет return и все что к нему прикревпено в функции 
- если в функции конструктора мы возвращаем примитив вместо объекта то он будет отброшен и вместо него вернется `this` объекта
- если в конструкторе нет аргументов то стандарт допускает опускать наличие скобок `const dog = new Animal`
- Если мы создаем объект через функцию, то публичные поля будут доступны если мы их обьявим через `this` остальные локальные переменные будут недоступны

## ООП в JS функциональный стиль
- приватный член - локальные переменные и аргументы конструктора
- публичны член - все что биндится к this
- наследование - вызов функции конструктора родителя через call(this) или apply(this, arguments) в функции потомка, тем самым он расширит this методами родителя и если надо далее перепишет их методами потомка

## ООП в прототипном стиле
- Обьеккты в JS можно организовать в цепочки, так чтобы свойство отсутствующее в одном объекте искалось в другом
- связующим звеном в этом случае выступает свойство `__proto__`
- `__proto__` это свойство обьекта, хранящее ссылку на другой обьект
- Если в одном из свойств - функции прототипа используется this, то будет использоваться контекст обьекта в котором вызвана эта функция
- При создании обьектов через new наследование производится путем присвоения `[Children].prototype = new [Parent]()`
- Свойство prototype может быть у любого объекта, но особый смысл оно имеет при назначении функции конструктору
- Классическая схема наследования `Children.prototype.__proto__ = Parent.prototype`
- В общем случае для мультибраузерной поддержки лучше применять `Children.prototype = Object.create(Parent.prototype); Children.prototype.constructor = Children;`
- Вызов конструктора родителя выполняется в теле потомка `Parent.apply(this, arguments)`
- Вызов переопределенного в потомке метода родителя `Parent.prototype.method.apply(this, argumnets)`

## Symbol
Тип данных служащий для создания уникальных идентификаторов. Может входить в глобальный реестр (в который входят так же зарезервированные нативные символы)

## Итератор
Итератор – объект, предназначенный для перебора другого объекта.
Зарезервированный Символ предоставляющий реализацию функции итерируемых свойств объекта
У итератора должен быть метод next(), возвращающий объект {done: Boolean, value: any}, где value – очередное значение, а done: true в конце.

## WeakMap / WeakSet
Особый тип map и set который не препятствует сборщику мусора удалять хранимый в коллекции элемент в случае если он удален из вне коллекции.
- Обьект будет автоматически удален из коллекции если будет удален объект в иточнике из которого он поступил в коллекцию


## интервалы таймауты
- система не гарантирует заданное время, задержки интервала при работе в высокой нагрузке или в фоноваом режиме
- минимальная задержка 4мс
- для гарантии задержки между регулярными вызовами надо использовать рекурсивный setTimeout

## RX
Реактивное программирование — парадигма программирования, ориентированная на потоки данных и распространение изменений.


## JIT коипиляция
Это процесс перевода кода, написанного на языке программирования, в машинный код во время выполнения программы или приложения

## AOT компиляция
Это процесс перевода кода, записанного на языке программирования, в машинный код перед выполнением. Это уменьшает накладные расходы во время выполнения и компилирует все файлы вместе, а не по отдельности.

## WEBPACK
- Сборщик проекта
  - Загрузчики - процессоры чтения и транспиляции в примтивные web типы для типов контента (html, js, ts, sass, css)
  - Плагины - различные процессоры расширяющие функционал загрузчиков контента
  - Разделене конфигураций в зависимости от окружения
  - Отложенная загрузка модулей
  - Удаление с помошью tree shaking забытого кода
  - hot reload (перезагружает измененный файл не теряя текущего контекста приложения), live reload (перезагружкает все приложение при изменении файла)
  - кеширование версии сборок, чанков, файлов
- Хеш - при каждой сборке для всех файлов одинаковый хеш
- Chunchash - только для отдельных файлов, содержимое которых изменилось
- Contenhash - хеш на основе проверки изменений содержимого файла

## Каверзные вопросы по Алгоритмам

- В последовательности записаны целые числа от 1 до N в произвольном порядке, но одно из чисел пропущено (остальные встречаются ровно по одному разу). N заранее неизвестно. Определить пропущенное число
  - Проходим по всем числам, находим их Количество K и сумму S
  - Шаг равен 1; N=K+1, сумма чисел от 1 до N = (K+1)*(К+2)/2
  - Пропущенное число равно (K+1)(K+2)/2-S

-  В последовательности записаны целые числа. Одно из чисел встречается ровно один раз, остальные — по два раза. Найти число, которое встречается один раз
   - Найти XOR всех чисел (исключающее ИЛИ) - разность множеств
   - Для функции трёх и более переменных — результат выполнения операции будет истинным только тогда, когда количество аргументов, равных 1, составляющих текущий набор, — нечётное.




